using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using Lens.SyntaxTree.SyntaxTree;
using Lens.SyntaxTree.SyntaxTree.ControlFlow;
using Lens.SyntaxTree.Utils;

namespace Lens.SyntaxTree.Compiler
{
	/// <summary>
	/// The main context class that stores information about currently compiled Assembly.
	/// </summary>
	public partial class Context
	{
		#region Constructors
		
		private Context()
		{
			var an = new AssemblyName(getAssemblyName());
			MainAssembly = AppDomain.CurrentDomain.DefineDynamicAssembly(an, AssemblyBuilderAccess.RunAndSave);
			MainModule = MainAssembly.DefineDynamicModule(an.Name, an.Name + ".dll");
			MainType = MainModule.DefineType("_ScriptRootType", TypeAttributes.Public | TypeAttributes.Class);
			EntryPoint = MainType.DefineMethod("_ScriptBody", MethodAttributes.Static | MethodAttributes.Public, typeof(object), Type.EmptyTypes);

			_TypeResolver = new TypeResolver();

			DefinedFunctions = new List<NamedFunctionNode>();
			DefinedRecords = new List<RecordDefinitionNode>();
			DefinedTypes = new List<TypeDefinitionNode>();
			ScriptBody = new CodeBlockNode();
		}

		/// <summary>
		/// Creates the context from a stream of nodes.
		/// </summary>
		/// <param name="nodes">Stream of nodes generated by the parser.</param>
		public static Context CreateFromNodes(IEnumerable<NodeBase> nodes)
		{
			var ctx = new Context();
			foreach (var currNode in nodes)
			{
				if (currNode is TypeDefinitionNode)
					ctx.DefinedTypes.Add(currNode as TypeDefinitionNode);
				else if (currNode is RecordDefinitionNode)
					ctx.DefinedRecords.Add(currNode as RecordDefinitionNode);
				else if (currNode is NamedFunctionNode)
					ctx.DefinedFunctions.Add(currNode as NamedFunctionNode);
				else if(currNode is UsingNode)
					ctx._TypeResolver.AddNamespace((currNode as UsingNode).Namespace);
				else
					ctx.ScriptBody.Add(currNode);
			}

			ctx.prepare();
			return ctx;
		}

		#endregion

		#region Properties

		private static int _AssemblyCounter;

		private TypeResolver _TypeResolver;

		/// <summary>
		/// The assembly that's being currently built.
		/// </summary>
		public AssemblyBuilder MainAssembly { get; private set; }

		/// <summary>
		/// The main module of the current assembly.
		/// </summary>
		public ModuleBuilder MainModule { get; private set; }

		/// <summary>
		/// The main type of the module.
		/// </summary>
		public TypeBuilder MainType { get; private set; }

		/// <summary>
		/// The entry point of the assembly.
		/// </summary>
		public MethodBuilder EntryPoint { get; private set; }

		/// <summary>
		/// The defined records.
		/// </summary>
		public List<RecordDefinitionNode> DefinedRecords { get; private set; }

		/// <summary>
		/// The defined types.
		/// </summary>
		public List<TypeDefinitionNode> DefinedTypes { get; private set; }

		/// <summary>
		/// The defined functions.
		/// </summary>
		public List<NamedFunctionNode> DefinedFunctions { get; private set; }

		/// <summary>
		/// The body of the script.
		/// </summary>
		public CodeBlockNode ScriptBody { get; private set; }

		#endregion

		#region Methods

		/// <summary>
		/// Add a new type to the list and ensure the name is unique.
		/// </summary>
		/// <param name="node"></param>
		public void AddType(TypeDefinitionNode node)
		{
			ensureTypeNameUniqueness(node.Name);
			DefinedTypes.Add(node);
		}

		/// <summary>
		/// Add a new record to the list and ensure the name is unique.
		/// </summary>
		/// <param name="node"></param>
		public void AddRecord(RecordDefinitionNode node)
		{
			ensureTypeNameUniqueness(node.Name);
			DefinedRecords.Add(node);
		}
		
		/// <summary>
		/// Resolve a type by it's string signature.
		/// Warning: this method might return a TypeBuilder as well as a Type, if the signature points to an inner type.
		/// This means 
		/// </summary>
		/// <param name="signature"></param>
		/// <returns></returns>
		public Type ResolveType(string signature)
		{
			throw new NotImplementedException();
		}
		
		#endregion

		#region Helpers

		/// <summary>
		/// Generates a unique assembly name.
		/// </summary>
		private static string getAssemblyName()
		{
			lock(typeof(Context))
				_AssemblyCounter++;
			return "_CompiledAssembly" + _AssemblyCounter;
		}

		/// <summary>
		/// Ensure the name is not a defined type or a record.
		/// </summary>
		/// <param name="typeName"></param>
		private void ensureTypeNameUniqueness(string typeName)
		{
			foreach (var curr in DefinedTypes)
				if (curr.Name == typeName)
					throw new LensCompilerException(string.Format("A type named {0} is already defined!", typeName));

			foreach (var curr in DefinedRecords)
				if (curr.Name == typeName)
					throw new LensCompilerException(string.Format("A record named {0} is already defined!", typeName));
		}

		/// <summary>
		/// Registers all structures in the assembly.
		/// </summary>
		private void prepare()
		{
			foreach(var type in DefinedTypes.OfType<TypeDefinitionNodeBase>().Union(DefinedRecords))
				type.TypeBuilder = MainModule.DefineType(type.Name, TypeAttributes.Public | TypeAttributes.Class | TypeAttributes.Sealed);

			foreach (var func in DefinedFunctions)
			{
				var retType = func.Body.GetExpressionType(this);
				var args = func.Arguments.Select(x => ResolveType(x.Value.Type.Signature)).ToArray();
				func.MethodBuilder = MainType.DefineMethod(
					func.Name,
					MethodAttributes.Private | MethodAttributes.Static,
					CallingConventions.Standard,
					retType,
					args
				);

				var argId = 1;
				foreach (var argInfo in func.Arguments)
				{
					// todo: ref parameters?
					var arg = argInfo.Value;
					var argKind = arg.Modifier == ArgumentModifier.Out ? ParameterAttributes.Out : ParameterAttributes.In;
					arg.ParameterBuilder = func.MethodBuilder.DefineParameter(argId, argKind, arg.Name);
					argId++;
				}
			}

			// after the types are initialized, we can now define fields
			// this solves the problem of a possible circular reference between types' fields,
			// when type A has a field of type B and type B has a field of type A
//			foreach (var curr in DefinedTypes)
//				prepareTypeLabels(curr);
//
//			foreach (var curr in DefinedRecords)
//				prepareRecordFields(curr);
		}

		#endregion
	}
}
