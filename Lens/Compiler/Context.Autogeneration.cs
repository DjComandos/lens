using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Lens.SyntaxTree;
using Lens.SyntaxTree.ControlFlow;
using Lens.Translations;
using Lens.Utils;

namespace Lens.Compiler
{
	internal partial class Context
	{
		#region Pure function wrappers

		private void createPureWrapper(MethodEntity method)
		{
			if (method.ReturnType.IsVoid())
				Error(CompilerMessages.PureFunctionReturnUnit, method.Name);

			var pureName = string.Format(EntityNames.PureMethodNameTemplate, method.Name);
			var pure = MainType.CreateMethod(pureName, method.ReturnTypeSignature, method.Arguments.Values, true);
			pure.Kind = MethodEntityKind.AutoGenerated;
			pure.Body = method.Body;
			method.Kind = MethodEntityKind.AutoGenerated;

			var argCount = method.Arguments != null ? method.Arguments.Count : method.ArgumentTypes.Length;

			if (argCount >= 8)
				Error(CompilerMessages.PureFunctionTooManyArgs, method.Name);

			if (argCount == 0)
				createPureWrapper0(method, pureName);
			else if (argCount == 1)
				createPureWrapper1(method, pureName);
			else
				createPureWrapperMany(method, pureName);

			DeclareMethodForProcessing(method);
		}

		private void createPureWrapper0(MethodEntity wrapper, string originalName)
		{
			var fieldName = string.Format(EntityNames.PureMethodCacheNameTemplate, wrapper.Name);
			var flagName = string.Format(EntityNames.PureMethodCacheFlagNameTemplate, wrapper.Name);

			MainType.CreateField(fieldName, wrapper.ReturnTypeSignature, true);
			MainType.CreateField(flagName, typeof(bool), true);

			wrapper.Body = Expr.Block(

				// if (not $flag) $cache = $internal (); $flag = true
				Expr.If(
					Expr.Not(Expr.GetMember(EntityNames.MainTypeName, flagName)),
					Expr.Block(
						Expr.SetMember(
							EntityNames.MainTypeName,
							fieldName,
							Expr.Invoke(EntityNames.MainTypeName, originalName)
						),
						Expr.SetMember(EntityNames.MainTypeName, flagName, Expr.True())
					)
				),

				// $cache
				Expr.GetMember(EntityNames.MainTypeName, fieldName)
			);
		}

		private void createPureWrapper1(MethodEntity wrapper, string originalName)
		{
			var args = wrapper.GetArgumentTypes(this);
			var argName = wrapper.Arguments[0].Name;

			var fieldName = string.Format(EntityNames.PureMethodCacheNameTemplate, wrapper.Name);
			var fieldType = typeof(Dictionary<,>).MakeGenericType(args[0], wrapper.ReturnType);

			MainType.CreateField(fieldName, fieldType, true);

			wrapper.Body = Expr.Block(

				// if ($dict == null) $dict = new Dictionary<$argType, $valueType> ()
				Expr.If(
					Expr.Equal(
						Expr.GetMember(EntityNames.MainTypeName, fieldName),
						Expr.Null()
					),
					Expr.Block(
						Expr.SetMember(
							EntityNames.MainTypeName, fieldName,
							Expr.New(fieldType)
						)
					)
				),

				// if(not $dict.ContainsKey key) $dict.Add ($internal arg)
				Expr.If(
					Expr.Not(
						Expr.Invoke(
							Expr.GetMember(EntityNames.MainTypeName, fieldName),
							"ContainsKey",
							Expr.Get(argName)
						)
					),
					Expr.Block(
						Expr.Invoke(
							Expr.GetMember(EntityNames.MainTypeName, fieldName),
							"Add",
							Expr.Get(argName),
							Expr.Invoke(EntityNames.MainTypeName, originalName, Expr.Get(argName))
						)
					)
				),

				// $dict[arg]
				Expr.GetIdx(
					Expr.GetMember(EntityNames.MainTypeName, fieldName),
					Expr.Get(argName)
				)
			);
		}

		private void createPureWrapperMany(MethodEntity wrapper, string originalName)
		{
			var args = wrapper.GetArgumentTypes(this);

			var fieldName = string.Format(EntityNames.PureMethodCacheNameTemplate, wrapper.Name);
			var tupleType = FunctionalHelper.CreateTupleType(args);
			var fieldType = typeof(Dictionary<,>).MakeGenericType(tupleType, wrapper.ReturnType);

			MainType.CreateField(fieldName, fieldType, true);

			var argGetters = wrapper.Arguments.Select(a => (NodeBase)Expr.Get(a)).ToArray();
			var tupleName = "<args>";

			wrapper.Body = Expr.Block(

				// $tmp = new Tuple<...> $arg1 $arg2 ...
				Expr.Let(tupleName, Expr.New(tupleType, argGetters)),

				// if ($dict == null) $dict = new Dictionary<$tupleType, $valueType> ()
				Expr.If(
					Expr.Equal(
						Expr.GetMember(EntityNames.MainTypeName, fieldName),
						Expr.Null()
					),
					Expr.Block(
						Expr.SetMember(
							EntityNames.MainTypeName, fieldName,
							Expr.New(fieldType)
						)
					)
				),

				// if(not $dict.ContainsKey key) $dict.Add ($internal arg)
				Expr.If(
					Expr.Not(
						Expr.Invoke(
							Expr.GetMember(EntityNames.MainTypeName, fieldName),
							"ContainsKey",
							Expr.Get(tupleName)
						)
					),
					Expr.Block(
						Expr.Invoke(
							Expr.GetMember(EntityNames.MainTypeName, fieldName),
							"Add",
							Expr.Get(tupleName),
							Expr.Invoke(EntityNames.MainTypeName, originalName, argGetters)
						)
					)
				),

				// $dict[arg]
				Expr.GetIdx(
					Expr.GetMember(EntityNames.MainTypeName, fieldName),
					Expr.Get(tupleName)
				)

			);
		}

		#endregion

		#region Iterators

		private void createIterator(MethodEntity method)
		{
			var returnType = method.ReturnType ?? ResolveType(method.ReturnTypeSignature);
			if (!returnType.IsGenericType || returnType.GetGenericTypeDefinition() != typeof(IEnumerable<>))
				Error(method.ReturnTypeSignature, CompilerMessages.IteratorReturnTypeIncorrect);

			var seqType = returnType.GetGenericArguments()[0];

			var enumerableType = typeof(IEnumerable<>).MakeGenericType(seqType);
			var enumeratorType = typeof(IEnumerator<>).MakeGenericType(seqType);

			var typeName = string.Format(EntityNames.IteratorTypeName, GetClosureId());
			var type = CreateType(typeName, null as string, true, false);
			type.Kind = TypeEntityKind.Iterator;
			type.Interfaces = new[] { enumerableType, enumeratorType, typeof(IEnumerator) };

			// default ctor
			type.CreateConstructor();

			// GetEnumerator<T>
			var enumGen = type.CreateMethod("GetEnumerator", enumeratorType, isVirtual: true);
			enumGen.Kind = MethodEntityKind.AutoGenerated;
			enumGen.Body = Expr.Block(Expr.This());
			type.AddImplementation(enumerableType.GetMethod("GetEnumerator"), enumGen);

			// GetEnumerator
			var enumDef = type.CreateMethod("GetEnumeratorDefault", typeof(IEnumerator), isVirtual: true);
			enumDef.Kind = MethodEntityKind.AutoGenerated;
			enumDef.Body = Expr.Block(Expr.This());
			type.AddImplementation(typeof(IEnumerable).GetMethod("GetEnumerator"), enumDef);

			// main method
			var moveNext = type.CreateMethod("MoveNext", typeof(bool), isVirtual: true);
			moveNext.ExtractBodyFrom(method);
			moveNext.Kind = MethodEntityKind.Iterator;
			type.AddImplementation(typeof(IEnumerator).GetMethod("MoveNext"), moveNext);

			// _Current and _StateId
			type.CreateField(EntityNames.IteratorCurrentFieldName, seqType);
			type.CreateField(EntityNames.IteratorStateFieldName, typeof(int));

			// Current<T>
			var currGen = type.CreateProperty("Current", seqType, hasSetter: false, isStatic: false, isVirtual: true);
			currGen.Getter.Body = Expr.Block(
				Expr.GetMember(
					Expr.This(),
					EntityNames.IteratorCurrentFieldName
				)
			);
			type.AddImplementation(enumeratorType.GetProperty("Current").GetGetMethod(), currGen.Getter);

			// Current
			var currDef = type.CreateProperty("CurrentDefault", typeof(object), hasSetter: false, isStatic: false, isVirtual: true);
			currDef.Getter.Body = Expr.Block(
				Expr.Cast(
					Expr.GetMember(
						Expr.This(),
						EntityNames.IteratorCurrentFieldName
					),
					typeof(object)
				)
			);
			type.AddImplementation(typeof(IEnumerator).GetProperty("Current").GetGetMethod(), currDef.Getter);

			// dispose
			var dispose = type.CreateMethod("Dispose", typeof(void), isVirtual: true);
			dispose.Kind = MethodEntityKind.AutoGenerated;
			dispose.Body = Expr.Block(Expr.Dynamic(ctx => ctx.CurrentILGenerator.EmitNop()));
			type.AddImplementation(typeof(IDisposable).GetMethod("Dispose"), dispose);

			// reset
			var reset = type.CreateMethod("Reset", typeof(void), isVirtual: true);
			reset.Kind = MethodEntityKind.AutoGenerated;
			reset.Body = Expr.Block(
				Expr.SetMember(
					Expr.This(),
					EntityNames.IteratorStateFieldName,
					Expr.Int(0)
				)
			);
			type.AddImplementation(typeof(IEnumerator).GetMethod("Reset"), reset);

			// connect base method to iterator
			method.Kind = MethodEntityKind.AutoGenerated;
			method.YieldStatements = new List<YieldNode>();

			var varName = "<iter>";
			method.Body = Expr.Block(Expr.Let(varName, Expr.New(typeName)));

			foreach (var curr in moveNext.Scope.Names.Values)
			{
				if(curr.Mapping == LocalNameMapping.Closure)
					throw new LensCompilerException(string.Format(CompilerMessages.ClosureIterator, curr.Name, method.Name));

				var fieldName = string.Format(EntityNames.ClosureFieldNameTemplate, curr.Name);
				curr.Mapping = LocalNameMapping.Field;
				curr.BackingFieldName = fieldName;
				type.CreateField(fieldName, curr.Type);
			}

			foreach (var arg in method.Arguments)
			{
				var fieldName = string.Format(EntityNames.ClosureFieldNameTemplate, arg);
				var getter = Expr.SetMember(Expr.Get(varName), fieldName, Expr.Get(arg));
				method.Body.Add(getter);
			}

			method.Body.Add(Expr.Get(varName));

			DeclareMethodForProcessing(method);
		}

		#endregion

		#region Misc
		
		/// <summary>
		/// Creates a "Run" method 
		/// </summary>
		private void createEntryPoint()
		{
			var ep = MainType.CreateMethod(EntityNames.EntryPointMethodName, typeof(void), null, true);
			ep.Body = Expr.Block(
				Expr.Invoke(Expr.New(EntityNames.MainTypeName), "Run"),
				Expr.Unit()
			);
		}

		#endregion
	}
}
